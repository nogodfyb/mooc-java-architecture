# JVM调优理论篇

![](img\1.png)

# 内存结构

![](img\2.png)

![](img\3.png)

![](img\4.png)

![](img\5.png)

![](img\6.png)

![](img\7.png)

![](img\8.png)

## demo

```java
package com.imooc.jvm.jvm;

public class JVMTest1 {
    
    public static void main(String[] args) {
        Demo demo = new Demo("aaa");
        demo.printName();
    }
    
}

class Demo {
    private String name;

    public Demo(String name) {
        this.name = name;
    }

    public void printName() {
        System.out.println(this.name);
    }
}
```

![](img\9.png)

# 类加载机制

## 类加载过程

![](img\10.png)

![](img\11.png)

![](img\12.png)

![](img\13.png)

![](img\14.png)

![](img\15.png)

![](img\16.png)

![](img\17.png)

![](img\18.png)

![](img\19.png)

# 编译器优化

## 字节码如何运行

![](img\20.png)

### ![](img\21.png)

![](img\22.png)

![](img\23.png)

![](img\24.png)

![](img\25.png)

![](img\26.png)

![](img\27.png)

![](img\28.png)

### 如何找到热点代码

![](img\29.png)

![](img\30.png)

![](img\31.png)

![](img\32.png)

### 方法调用计数器流程

![](img\33.png)

![](img\34.png)

![](img\35.png)

### JVM参数

![](img\36.png)

## 方法内联

demo

```java
package com.imooc.jvm.jvm;

public class InlineTest1 {
    
    private static int add1(int x1, int x2, int x3, int x4) {
        return add2(x1, x2) + add2(x3, x4);
    }

    private static int add2(int x1, int x2) {
        return x1 + x2;
    }

    // 内联后
    private static int addInline(int x1, int x2, int x3, int x4) {
        return x1 + x2 + x3 + x4;
    }
}
```

![](img\37.png)

![](img\38.png)

![](img\39.png)

![](img\40.png)

![](img\41.png)

![](img\42.png)

demo

```java
package com.imooc.jvm.jvm;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Random;

public class InlineTest2 {
    private static final Logger LOGGER = LoggerFactory.getLogger(InlineTest2.class);

    public static void main(String[] args) {
        long cost = compute();
        // 方法内联了416ms add1：12byte add2：4byte
        // 方法不内联580ms
        LOGGER.info("执行花费了{}ms", cost);
    }

    private static long compute() {
        long start = System.currentTimeMillis();
        int result = 0;
        Random random = new Random();
        for (int i = 0; i < 10000000; i++) {
            int a = random.nextInt();
            int b = random.nextInt();
            int c = random.nextInt();
            int d = random.nextInt();
            result = add1(a, b, c, d);
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    private static int add1(int x1, int x2, int x3, int x4) {
        return add2(x1, x2) + add2(x3, x4);
    }

    private static int add2(int x1, int x2) {
        return x1 + x2;
    }
}
```

# 逃逸分析

## 逃逸分析

分析变量能否逃出它的作用域

![](img\43.png)

demo

```java
package com.imooc.jvm.jvm;

class EscapeTest1 {
    public static SomeClass someClass;

    // 全局变量赋值逃逸
    public void globalVariablePointerEscape() {
        someClass = new SomeClass();
    }

    // 方法返回值逃逸
    // someMethod(){
    //   SomeClass someClass = methodPointerEscape();
    // }
    public SomeClass methodPointerEscape() {
        return new SomeClass();
    }

    // 实例引用传递逃逸
    public void instancePassPointerEscape() {
        this.methodPointerEscape()
            .printClassName(this);
    }

    public void someTest() {
        SomeTest someTest = new SomeTest();
        someTest.age = 1;
        someTest.id = 1;

        // 开启标量替换之后，
        int age = 1;
        int id = 1;
    }
}

class SomeClass {
    public void printClassName(EscapeTest1 escapeTest1) {
        System.out.println(escapeTest1.getClass().getName());
    }
}

class SomeTest {
    int id;
    int age;
}
```

![](img\44.png)

![](img\45.png)

![](img\46.png)

## 标量替换

![](img\47.png)

![](img\48.png)

## 栈上分配

![](img\49.png)

## JVM参数

![](img\50.png)