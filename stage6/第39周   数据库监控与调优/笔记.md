# 数据库调优的维度

![](img\1.png)

## 业务需求

![](img\2.png)

![](img\3.png)

## 系统架构

![](img\4.png)

## SQL及索引

![](img\5.png)

## 表结构

![](img\6.png)

## 数据库参数设置

![](img\7.png)

## 系统配置

![](img\8.png)

## 硬件

![](img\9.png)

# 测试数据与工具

![](img\10.png)

https://dev.mysql.com/doc/index-other.html

## 导入数据

```shell
mysql -uroot -p123 < employees.sql
```

## 检测导入数据是否正确

```shell
mysql -uroot -p123 -t < test_employees_md5.sql
```

# 慢查询日志

![](img\11.png)

![](img\12.png)

## 相关参数

![](img\13.png)

## 使用方式

![](img\14.png)

开启日志

```sql
set global slow_query_log = 'on'
```

```sql
set global log_output = 'FILE,TABLE'
```

```sql
set global long_query_time = 0.001

show VARIABLES like '%long_query_time%'
```

```sql
set global log_queries_not_using_indexes = 'ON'
```

分析慢查询日志

```sql
select *,CONVERT(sql_text USING utf8 ) from mysql.slow_log
```

基于文件分析

```sql
show VARIABLES like '%slow_query_log_file%'
```



mysqldumpslow分析

# EXPLAIN

```
https://segmentfault.com/a/1190000008131735
```

# SQL性能分析

## navicat

![](img\15.png)

![](img\16.png)

# OPTIMIZER TRACE

# 数据库诊断命令

```sql
SHOW PROCESSLIST

SHOW STATUS

SHOW VARIABLES

SHOW TABLE STATUS

SHOW INDEX FROM employees

SHOW ENGINE INNODB status
```

# 索引

## B-TREE（B+TREE数据结构）

![](img\17.png)

![](img\18.png)

## HASH

![](img\19.png)

![](img\20.png)

## FULL TEXT

## 空间索引(R-Tree)

## 创建索引的原则

![](img\21.png)

![](img\22.png)

![](img\23.png)

![](img\24.png)

## 索引失效与解决方案

### 索引列不独立

独立是指:列不能是表达式的一部分，也不能是函数的参数

![](img\25.png)

![](img\26.png)

![](img\27.png)

![](img\28.png)

### 使用了左模糊

![](img\29.png)

### 使用OR查询的部分字段没有索引

### 字符串条件未使用‘ ’引起来

![](img\30.png)

![](img\31.png)

### 不符合最左前缀原则的查询

联合索引要符合最左前缀原则，否则会失效

### 索引字段建议添加NOT NULL约束

### 隐式转换导致索引失效

![](img\32.png)

## 索引调优技巧

### 长字段的索引调优

```sql
# noinspection SqlResolveForFile

-- 长字段的调优
select *
from employees
where first_name = 'Facello';

insert into employees (emp_no, birth_date, first_name, last_name, gender, hire_date, first_name_hash)
    value (
           999999, now(),
           '大目......................',
           '大', 'M', now(),
           CRC32('大目......................')
    );
-- first_name_hash的值应该具备以下要求：
-- 1. 字段的长度应该比较的小，SHA1/MD5是不合适的
-- 2. 应当尽量避免hash冲突，就目前来说，流行使用CRC32()或者FNV64()
select *
from employees
where first_name_hash = CRC32('Facello')
  and first_name = 'Facello';

-- 长字段的调优
select *
from employees
where first_name like 'Facello%';
-- 前缀索引
alter table employees add key (first_name(5));
-- 完整列的选择性：0.0042[这个字段的最大选择性了]
select count(distinct first_name)/count(*) from employees;

-- 5: 0.0038   6:0.0041   7:0.0042
select count(distinct left(first_name, 8))/count(*) from employees;
-- 结论
alter table employees add key (first_name(7));
-- 局限性：无法做order by、group by；无法使用覆盖索引
-- "后缀索引"：额外创建一个字段，比如说first_name_reverse，在存储的时候，把first_name的值
-- 翻转过来再存储。比方说：Facello  ==> ollecaF存储到first_name_reverse
```



### 使用组合索引的技巧

![](img\33.png)

### 覆盖索引

![](img\34.png)



### 冗余,重复索引,未使用的优化

重复索引

```sql
create table test_table
(
    id int not null primary key auto_increment,
    a  int not null,
    b  int not null,
    UNIQUE (id),
    INDEX (id)
) ENGINE = InnoDB;
-- 发生了重复索引，改进方案：
create table test_table
(
    id int not null primary key auto_increment,
    a  int not null,
    b  int not null
) ENGINE = InnoDB;
```

冗余索引

![](img\35.png)

```sql
create table test_table
(
    id int not null primary key auto_increment,
    a  int not null,
    b  int not null
) ENGINE = InnoDB;

explain
select *
from salaries
where from_date = '1986-06-26'
order by emp_no;

-- index(from_date): type=ref    extra=null，使用了索引
-- index(from_date) 某种意义上来说就相当于index(from_date, emp_no)
-- index(from_date, to_date): type=ref    extra=Using filesort，order by子句无法使用索引
-- index(from_date, to_date)某种意义上来说就相当于index(from_date, to_date, emp_no)

```

未使用的索引

![](img\36.png)

### 排序优化

# JOIN语句优化

join的种类